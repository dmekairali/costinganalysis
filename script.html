<script>
// Global variables
let costingData = [];
let filteredCostingData = [];
let currentEditContext = null;
let costingDataTable = null;

// Initialize dashboard
function initializeDashboard() {
    showLoading(true);
    google.script.run
        .withSuccessHandler(data => {
            costingData = data;
            filteredCostingData = data; // Initialize filtered data
            costingDataTable = $('#costing-table').DataTable({
                "scrollY": "75vh",
                "scrollX": true,
                "scrollCollapse": true,
                "paging": false,
                "ordering": true,
                "info": false,
                "fixedHeader": {
                    "header": true,
                    "headerOffset": 50
                }
            });
            populateTable();
            updateMLInsights();
            attachEventListeners();
            showLoading(false);
        })
        .withFailureHandler(error => {
            console.error('Error importing data:', error);
            showNotification('Failed to load data from Google Sheet.', 'error');
            showLoading(false);
        })
        .importCostingData();
}

// Populate table with data
function populateTable() {
    costingDataTable.clear();
    const rows = filteredCostingData.map((item, index) => {
        const originalIndex = costingData.findIndex(d => d.productionId === item.productionId);

        const caDeviation = calculateDeviation(item.ca.benchmark, item.ca.newBenchmark);
        const tocDeviation = calculateDeviation(item.toc.benchmark, item.toc.newBenchmark);
        const timeDeviation = calculateTimeDeviation(item.time.benchmark, item.time.newBenchmark);

        return [
            `<strong>${item.productName}</strong>`,
            item.productionId,
            item.package,
            item.qty.toLocaleString(),
            `<div class="notes-col">${item.notes}</div>`,
            `<div class="ai-notes-col">${item.aiNotes || ''}</div>`,
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'ca.correct')">â‚¹${item.ca.correct.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.ca.benchmark.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.ca.last3Prod.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.ca.last3Month.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.ca.last12Month.toFixed(2)}</div>`,
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'ca.newBenchmark')">â‚¹${item.ca.newBenchmark.toFixed(2)}</div>`,
            `<div class="deviation-cell">${caDeviation}</div>`,
            `<div class="status-cell ${getStatusClass(item.ca.status)}" onclick="editStatus(${originalIndex}, 'ca')">${formatStatus(item.ca.status)}</div>`,
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'toc.correct')">â‚¹${item.toc.correct.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.toc.benchmark.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.toc.last3Prod.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.toc.last3Month.toFixed(2)}</div>`,
            `<div class="cost-cell">â‚¹${item.toc.last12Month.toFixed(2)}</div>`,
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'toc.newBenchmark')">â‚¹${item.toc.newBenchmark.toFixed(2)}</div>`,
            `<div class="deviation-cell">${tocDeviation}</div>`,
            `<div class="status-cell ${getStatusClass(item.toc.status)}" onclick="editStatus(${originalIndex}, 'toc')">${formatStatus(item.toc.status)}</div>`,
            `<div class="time-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'time.correct')">${item.time.correct}</div>`,
            `<div class="time-cell">${item.time.benchmark}</div>`,
            `<div class="time-cell">${item.time.last3Prod}</div>`,
            `<div class="time-cell">${item.time.last3Month}</div>`,
            `<div class="time-cell">${item.time.last12Month}</div>`,
            `<div class="time-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'time.newBenchmark')">${item.time.newBenchmark}</div>`,
            `<div class="deviation-cell">${timeDeviation}</div>`,
            `<div class="status-cell ${getStatusClass(item.time.status)}" onclick="editStatus(${originalIndex}, 'time')">${formatStatus(item.time.status)}</div>`,
        ];
    });
    costingDataTable.rows.add(rows).draw(false);
}

// Helper functions
function timeToSeconds(timeStr) {
    if (!timeStr || typeof timeStr !== 'string') return 0;
    const parts = timeStr.split(':').map(Number);
    if (parts.length !== 3) return 0;
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
}

function calculateDeviation(benchmark, newBenchmark) {
    if (benchmark === 0) return 'N/A';
    const deviation = ((newBenchmark - benchmark) / benchmark) * 100;
    return deviation.toFixed(1) + '%';
}

function calculateTimeDeviation(benchmarkTime, newBenchmarkTime) {
    const benchmarkSeconds = timeToSeconds(benchmarkTime);
    if (benchmarkSeconds === 0) return 'N/A';
    const newBenchmarkSeconds = timeToSeconds(newBenchmarkTime);
    const deviation = ((newBenchmarkSeconds - benchmarkSeconds) / benchmarkSeconds) * 100;
    return deviation.toFixed(1) + '%';
}

function getStatusClass(status) {
    switch(status) {
        case 'update': return 'status-update';
        case 'no_need': return 'status-no-need';
        default: return 'status-update';
    }
}

function formatStatus(status) {
    switch(status) {
        case 'update': return 'Update';
        case 'no_need': return 'No Need';
        default: return 'Update';
    }
}

// Edit functionality
function makeCellEditable(cell, rowIndex, fieldPath) {
    const currentValue = getNestedValue(costingData[rowIndex], fieldPath);
    $(cell).html(`<input type='text' value='${currentValue}'/>`).find('input').focus()
        .on('blur', function() {
            saveCell(this, rowIndex, fieldPath);
        })
        .on('keypress', function(e) {
            if (e.which === 13) {
                this.blur();
            }
        });
}

function saveCell(input, rowIndex, fieldPath) {
    const newValue = $(input).val();
    setNestedValue(costingData[rowIndex], fieldPath, newValue);
    filterAndPopulate();
    updateMLInsights();
    showNotification('Data updated successfully!', 'success');
}

function editStatus(rowIndex, section) {
    const newStatus = costingData[rowIndex][section].status === 'update' ? 'no_need' : 'update';
    
    if (section === 'ca') {
        costingData[rowIndex].ca.status = newStatus;
        costingData[rowIndex].toc.status = newStatus;
        costingData[rowIndex].time.status = newStatus;
    } else {
        costingData[rowIndex][section].status = newStatus;
    }
    
    filterAndPopulate();
    updateMLInsights();
    showNotification(`Status updated to: ${formatStatus(newStatus)}`, 'success');
}

function getNestedValue(obj, path) {
    return path.split('.').reduce((o, p) => o && o[p], obj);
}

function setNestedValue(obj, path, value) {
    const keys = path.split('.');
    const last = keys.pop();
    const target = keys.reduce((o, k) => o[k], obj);
    target[last] = isNaN(value) || value === '' ? value : parseFloat(value);
}

// AI-Powered Analysis and Recommendations
function updateMLInsights() {
    const totalItems = costingData.length;
    let deviationCount = 0;
    let totalOptimization = 0;
    
    costingData.forEach(item => {
        if (item.ca.benchmark > 0) {
            const caDeviation = ((item.ca.newBenchmark - item.ca.benchmark) / item.ca.benchmark) * 100;
            if (Math.abs(caDeviation) > 5) deviationCount++;
            if (item.ca.newBenchmark < item.ca.benchmark) {
                totalOptimization += item.ca.benchmark - item.ca.newBenchmark;
            }
        }
        if (item.toc.benchmark > 0) {
            const tocDeviation = ((item.toc.newBenchmark - item.toc.benchmark) / item.toc.benchmark) * 100;
            if (Math.abs(tocDeviation) > 5) deviationCount++;
            if (item.toc.newBenchmark < item.toc.benchmark) {
                totalOptimization += item.toc.benchmark - item.toc.newBenchmark;
            }
        }
    });
    
    const optimizationPercentage = totalItems > 0 ? ((totalOptimization / (totalItems * 80)) * 100).toFixed(1) : 0;
    
    document.getElementById('optimization-potential').textContent = optimizationPercentage + '%';
    document.getElementById('updates-needed').textContent = deviationCount.toString();
    document.getElementById('efficiency-score').textContent = '87%';
    document.getElementById('variance-alert').textContent = deviationCount > 3 ? 'High' : deviationCount > 1 ? 'Medium' : 'Low';
}

async function runAIAnalysis() {
    showNotification('ðŸ¤– Running AI analysis with OpenAI...', 'info');
    showLoading(true);
    
    const deviations = analyzeDeviations();
    if (deviations.length === 0) {
        showLoading(false);
        showNotification('No significant deviations found requiring AI analysis.', 'success');
        return;
    }
    
    google.script.run
        .withSuccessHandler(handleAIAnalysisSuccess)
        .withFailureHandler(handleAIAnalysisFailure)
        .runOpenAIAnalysis(deviations);
}

function handleAIAnalysisSuccess(aiRecommendations) {
    showLoading(false);

    aiRecommendations.forEach(rec => {
        const item = costingData[rec.index];
        if (!item) return; // Skip if item not found

        // Update status based on recommendation type
        const section = rec.type === 'CA Cost' ? 'ca' : 'toc';
        item[section].status = rec.status;
        
        // Add or update AI notes, appending if multiple recommendations exist for one item
        if (item.aiNotes) {
            item.aiNotes += `\n${rec.type}: ${rec.decisionNotes}`;
        } else {
            item.aiNotes = `${rec.type}: ${rec.decisionNotes}`;
        }
    });

    filterAndPopulate(); // This will re-draw the table with the new data
    showNotification('AI analysis complete. Table has been updated with recommendations.', 'success');
}

function handleAIAnalysisFailure(error) {
    showLoading(false);
    console.error('AI Analysis Error:', error);
    showNotification('An error occurred while communicating with the AI service. Please try again.', 'error');
}

function analyzeDeviations() {
    const deviations = [];
    const formatValue = (value) => value === 0 ? 'No data' : value;

    costingData.forEach((item, index) => {
        if (item.ca.benchmark > 0) {
            const caDeviation = ((item.ca.newBenchmark - item.ca.benchmark) / item.ca.benchmark) * 100;
            if (caDeviation > 5) {
                const devData = {
                    index,
                    product: item.productName,
                    productionId: item.productionId,
                    type: 'CA Cost',
                    currentBenchmark: formatValue(item.ca.benchmark),
                    proposedBenchmark: formatValue(item.ca.newBenchmark),
                    deviation: caDeviation,
                    last3Avg: formatValue(item.ca.last3Prod),
                    last3MonthAvg: formatValue(item.ca.last3Month),
                    last12MonthAvg: formatValue(item.ca.last12Month)
                };
                if (item.notes) devData.notes = item.notes;
                deviations.push(devData);
            }
        }
        if (item.toc.benchmark > 0) {
            const tocDeviation = ((item.toc.newBenchmark - item.toc.benchmark) / item.toc.benchmark) * 100;
            if (tocDeviation > 5) {
                const devData = {
                    index,
                    product: item.productName,
                    productionId: item.productionId,
                    type: 'TOC Cost',
                    currentBenchmark: formatValue(item.toc.benchmark),
                    proposedBenchmark: formatValue(item.toc.newBenchmark),
                    deviation: tocDeviation,
                    last3Avg: formatValue(item.toc.last3Prod),
                    last3MonthAvg: formatValue(item.toc.last3Month),
                    last12MonthAvg: formatValue(item.toc.last12Month)
                };
                if (item.notes) devData.notes = item.notes;
                deviations.push(devData);
            }
        }
    });
    return deviations;
}


function generateSmartRecommendations() {
    const deviations = analyzeDeviations();
    if (deviations.length === 0) {
        showNotification('No significant cost deviations found. All benchmarks are optimal!', 'success');
        return;
    }
    let recommendations = "ðŸŽ¯ Smart Cost Recommendations:\n\n";
    deviations.forEach((dev, index) => {
        const action = dev.deviation > 15 ? "URGENT REVIEW" : dev.deviation > 10 ? "REVIEW REQUIRED" : dev.deviation > 5 ? "MONITOR" : "OPTIMIZE";
        recommendations += `${index + 1}. ${dev.product} (${dev.type})\n   Current: â‚¹${dev.currentBenchmark.toFixed(2)} â†’ Proposed: â‚¹${dev.proposedBenchmark.toFixed(2)}\n   Deviation: ${dev.deviation.toFixed(1)}% | Action: ${action}\n\n`;
    });
    alert(recommendations);
}

// Google Sheets Integration
function importFromGoogleSheets() {
    showNotification('Loading data from Google Sheets...', 'info');
    google.script.run
        .withSuccessHandler(handleImportSuccess)
        .withFailureHandler(handleImportFailure)
        .importCostingData();
}

function handleImportSuccess(data) {
    if (data && data.length > 0) {
        costingData = data;
        filteredCostingData = data;
        filterAndPopulate();
        updateMLInsights();
        showNotification('Data imported successfully from Google Sheets!', 'success');
    } else {
        showNotification('No data found in Google Sheets.', 'error');
    }
}

function handleImportFailure(error) {
    console.error('Import Error:', error);
    showNotification('Failed to import data from Google Sheets.', 'error');
}

function saveToGoogleSheets() {
    showNotification('Saving data to Google Sheets...', 'info');
    google.script.run
        .withSuccessHandler(handleSaveSuccess)
        .withFailureHandler(handleSaveFailure)
        .saveCostingData(costingData);
}

function handleSaveSuccess() {
    showNotification('Data saved successfully to Google Sheets!', 'success');
}

function handleSaveFailure(error) {
    console.error('Save Error:', error);
    showNotification('Failed to save data to Google Sheets.', 'error');
}

// Filter and search functionality (Simplified)
function filterAndPopulate() {
    const caDevFilter = parseFloat(document.getElementById('ca-deviation-filter').value);
    const tocDevFilter = parseFloat(document.getElementById('toc-deviation-filter').value);
    const timeDevFilter = parseFloat(document.getElementById('time-deviation-filter').value);

    filteredCostingData = costingData.filter(item => {
        const caDev = Math.abs(parseFloat(calculateDeviation(item.ca.benchmark, item.ca.newBenchmark))) || 0;
        const tocDev = Math.abs(parseFloat(calculateDeviation(item.toc.benchmark, item.toc.newBenchmark))) || 0;
        const timeDev = Math.abs(parseFloat(calculateTimeDeviation(item.time.benchmark, item.time.newBenchmark))) || 0;

        return caDev >= caDevFilter && tocDev >= tocDevFilter && timeDev >= timeDevFilter;
    });
    
    populateTable();
}

function bulkUpdateBenchmarks() {
    const confirmed = confirm('Are you sure you want to bulk update all benchmark costs?');
    if (confirmed) {
        costingData.forEach(item => {
            item.ca.benchmark = item.ca.newBenchmark;
            item.toc.benchmark = item.toc.newBenchmark;
            item.ca.status = 'approved';
            item.toc.status = 'approved';
        });
        filterAndPopulate();
        updateMLInsights();
        showNotification('Bulk benchmark update completed!', 'success');
    }
}

function bulkUpdateStatus(section) {
    const status = document.getElementById(`${section}-bulk-status`).value;
    costingData.forEach(item => {
        item[section].status = status;
    });
    filterAndPopulate();
    showNotification(`${section.toUpperCase()} statuses updated to: ${formatStatus(status)}`, 'success');
}

// Utility functions
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 100);
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => document.body.removeChild(notification), 300);
    }, 3000);
}

function showLoading(show) {
    const loader = document.getElementById('loading-indicator');
    loader.style.display = show ? 'block' : 'none';
}

function attachEventListeners() {
    // Modal listeners
    document.addEventListener('click', (event) => { if (event.target === document.getElementById('edit-modal')) closeModal(); });
    document.getElementById('edit-new-value').addEventListener('keypress', (event) => { if (event.key === 'Enter') saveEdit(); });

    // Deviation filters
    ['ca', 'toc', 'time'].forEach(section => {
        const filter = document.getElementById(`${section}-deviation-filter`);
        const valueDisplay = document.getElementById(`${section}-deviation-value`);
        filter.addEventListener('input', () => {
            valueDisplay.textContent = `${filter.value}%`;
            filterAndPopulate();
        });
    });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', initializeDashboard);
</script>
