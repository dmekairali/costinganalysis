<script>
// Global variables
let costingData = [];
let filteredCostingData = [];
let currentEditContext = null;
let costingDataTable = null;

// Initialize dashboard
function initializeDashboard() {
    showLoading(true);
    google.script.run
        .withSuccessHandler(data => {
            costingData = data;
            filteredCostingData = data; // Initialize filtered data
            costingDataTable = $('#costing-table').DataTable({
                "scrollY": "500px",
                "scrollX": true,
                "scrollCollapse": true,
                "paging": false,
                "ordering": false,
                "info": false,
                "fixedHeader": {
                    "header": true,
                    "headerOffset": 50
                }
            });
            populateTable();
            updateMLInsights();
            attachEventListeners();
            showLoading(false);
        })
        .withFailureHandler(error => {
            console.error('Error importing data:', error);
            showNotification('Failed to load data from Google Sheet.', 'error');
            showLoading(false);
        })
        .importCostingData();
}

// Populate table with data
function populateTable() {
    costingDataTable.clear();
    const rows = filteredCostingData.map((item, index) => {
        const originalIndex = costingData.findIndex(d => d.productionId === item.productionId);

        const caDeviation = calculateDeviation(item.ca.benchmark, item.ca.newBenchmark);
        const tocDeviation = calculateDeviation(item.toc.benchmark, item.toc.newBenchmark);
        const timeDeviation = calculateTimeDeviation(item.time.benchmark, item.time.newBenchmark);

        return [
            `<strong>${item.productName}</strong>`,
            item.productionId,
            item.package,
            item.qty.toLocaleString(),
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'ca.correct')">‚Çπ${item.ca.correct.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.ca.benchmark.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.ca.last3Prod.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.ca.last3Month.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.ca.last12Month.toFixed(2)}</div>`,
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'ca.newBenchmark')">‚Çπ${item.ca.newBenchmark.toFixed(2)}</div>`,
            `<div class="deviation-cell">${caDeviation}</div>`,
            `<div class="status-cell ${getStatusClass(item.ca.status)}" onclick="editStatus(${originalIndex}, 'ca')">${formatStatus(item.ca.status)}</div>`,
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'toc.correct')">‚Çπ${item.toc.correct.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.toc.benchmark.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.toc.last3Prod.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.toc.last3Month.toFixed(2)}</div>`,
            `<div class="cost-cell">‚Çπ${item.toc.last12Month.toFixed(2)}</div>`,
            `<div class="cost-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'toc.newBenchmark')">‚Çπ${item.toc.newBenchmark.toFixed(2)}</div>`,
            `<div class="deviation-cell">${tocDeviation}</div>`,
            `<div class="status-cell ${getStatusClass(item.toc.status)}" onclick="editStatus(${originalIndex}, 'toc')">${formatStatus(item.toc.status)}</div>`,
            `<div class="time-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'time.correct')">${item.time.correct}</div>`,
            `<div class="time-cell">${item.time.benchmark}</div>`,
            `<div class="time-cell">${item.time.last3Prod}</div>`,
            `<div class="time-cell">${item.time.last3Month}</div>`,
            `<div class="time-cell">${item.time.last12Month}</div>`,
            `<div class="time-cell editable-cell" onclick="makeCellEditable(this, ${originalIndex}, 'time.newBenchmark')">${item.time.newBenchmark}</div>`,
            `<div class="deviation-cell">${timeDeviation}</div>`,
            `<div class="status-cell ${getStatusClass(item.time.status)}" onclick="editStatus(${originalIndex}, 'time')">${formatStatus(item.time.status)}</div>`,
        ];
    });
    costingDataTable.rows.add(rows).draw(false);
}

// Helper functions
function timeToSeconds(timeStr) {
    if (!timeStr || typeof timeStr !== 'string') return 0;
    const parts = timeStr.split(':').map(Number);
    if (parts.length !== 3) return 0;
    return parts[0] * 3600 + parts[1] * 60 + parts[2];
}

function calculateDeviation(benchmark, newBenchmark) {
    if (benchmark === 0) return 'N/A';
    const deviation = ((newBenchmark - benchmark) / benchmark) * 100;
    return deviation.toFixed(1) + '%';
}

function calculateTimeDeviation(benchmarkTime, newBenchmarkTime) {
    const benchmarkSeconds = timeToSeconds(benchmarkTime);
    if (benchmarkSeconds === 0) return 'N/A';
    const newBenchmarkSeconds = timeToSeconds(newBenchmarkTime);
    const deviation = ((newBenchmarkSeconds - benchmarkSeconds) / benchmarkSeconds) * 100;
    return deviation.toFixed(1) + '%';
}

function getStatusClass(status) {
    switch(status) {
        case 'update': return 'status-update';
        case 'no_need': return 'status-no-need';
        default: return 'status-update';
    }
}

function formatStatus(status) {
    switch(status) {
        case 'update': return 'Update';
        case 'no_need': return 'No Need';
        default: return 'Update';
    }
}

// Edit functionality
function makeCellEditable(cell, rowIndex, fieldPath) {
    const currentValue = getNestedValue(costingData[rowIndex], fieldPath);
    $(cell).html(`<input type='text' value='${currentValue}'/>`).find('input').focus()
        .on('blur', function() {
            saveCell(this, rowIndex, fieldPath);
        })
        .on('keypress', function(e) {
            if (e.which === 13) {
                this.blur();
            }
        });
}

function saveCell(input, rowIndex, fieldPath) {
    const newValue = $(input).val();
    setNestedValue(costingData[rowIndex], fieldPath, newValue);
    filterAndPopulate();
    updateMLInsights();
    showNotification('Data updated successfully!', 'success');
}

function editStatus(rowIndex, section) {
    const newStatus = costingData[rowIndex][section].status === 'update' ? 'no_need' : 'update';
    
    if (section === 'ca') {
        costingData[rowIndex].ca.status = newStatus;
        costingData[rowIndex].toc.status = newStatus;
        costingData[rowIndex].time.status = newStatus;
    } else {
        costingData[rowIndex][section].status = newStatus;
    }
    
    filterAndPopulate();
    updateMLInsights();
    showNotification(`Status updated to: ${formatStatus(newStatus)}`, 'success');
}

function getNestedValue(obj, path) {
    return path.split('.').reduce((o, p) => o && o[p], obj);
}

function setNestedValue(obj, path, value) {
    const keys = path.split('.');
    const last = keys.pop();
    const target = keys.reduce((o, k) => o[k], obj);
    target[last] = isNaN(value) || value === '' ? value : parseFloat(value);
}

// AI-Powered Analysis and Recommendations
function updateMLInsights() {
    const totalItems = costingData.length;
    let deviationCount = 0;
    let totalOptimization = 0;
    
    costingData.forEach(item => {
        if (item.ca.benchmark > 0) {
            const caDeviation = ((item.ca.newBenchmark - item.ca.benchmark) / item.ca.benchmark) * 100;
            if (Math.abs(caDeviation) > 5) deviationCount++;
            if (item.ca.newBenchmark < item.ca.benchmark) {
                totalOptimization += item.ca.benchmark - item.ca.newBenchmark;
            }
        }
        if (item.toc.benchmark > 0) {
            const tocDeviation = ((item.toc.newBenchmark - item.toc.benchmark) / item.toc.benchmark) * 100;
            if (Math.abs(tocDeviation) > 5) deviationCount++;
            if (item.toc.newBenchmark < item.toc.benchmark) {
                totalOptimization += item.toc.benchmark - item.toc.newBenchmark;
            }
        }
    });
    
    const optimizationPercentage = totalItems > 0 ? ((totalOptimization / (totalItems * 80)) * 100).toFixed(1) : 0;
    
    document.getElementById('optimization-potential').textContent = optimizationPercentage + '%';
    document.getElementById('updates-needed').textContent = deviationCount.toString();
    document.getElementById('efficiency-score').textContent = '87%';
    document.getElementById('variance-alert').textContent = deviationCount > 3 ? 'High' : deviationCount > 1 ? 'Medium' : 'Low';
}

async function runAIAnalysis() {
    showNotification('ü§ñ Running AI analysis with OpenAI...', 'info');
    showLoading(true);
    
    const deviations = analyzeDeviations();
    if (deviations.length === 0) {
        showLoading(false);
        showNotification('No significant deviations found requiring AI analysis.', 'success');
        return;
    }
    
    try {
        google.script.run
            .withSuccessHandler(handleAIAnalysisSuccess)
            .withFailureHandler(handleAIAnalysisFailure)
            .runOpenAIAnalysis(deviations);
            
    } catch (error) {
        showLoading(false);
        showNotification('AI analysis failed. Using fallback analysis.', 'error');
        generateFallbackRecommendations(deviations);
    }
}

function handleAIAnalysisSuccess(aiRecommendations) {
    showLoading(false);
    displayAIRecommendations(aiRecommendations);
    highlightAIRecommendations(aiRecommendations);
    showNotification('AI analysis complete! Check recommendations panel.', 'success');
}

function handleAIAnalysisFailure(error) {
    showLoading(false);
    console.error('AI Analysis Error:', error);
    const deviations = analyzeDeviations();
    generateFallbackRecommendations(deviations);
    showNotification('AI analysis failed. Using fallback analysis.', 'error');
}

function analyzeDeviations() {
    const deviations = [];
    costingData.forEach((item, index) => {
        if (item.ca.benchmark > 0) {
            const caDeviation = ((item.ca.newBenchmark - item.ca.benchmark) / item.ca.benchmark) * 100;
            if (caDeviation > 5) {
                deviations.push({ index, product: item.productName, productionId: item.productionId, type: 'CA Cost', currentBenchmark: item.ca.benchmark, proposedBenchmark: item.ca.newBenchmark, deviation: caDeviation, last3Avg: item.ca.last3Prod, last3MonthAvg: item.ca.last3Month, last12MonthAvg: item.ca.last12Month });
            }
        }
        if (item.toc.benchmark > 0) {
            const tocDeviation = ((item.toc.newBenchmark - item.toc.benchmark) / item.toc.benchmark) * 100;
            if (tocDeviation > 5) {
                deviations.push({ index, product: item.productName, productionId: item.productionId, type: 'TOC Cost', currentBenchmark: item.toc.benchmark, proposedBenchmark: item.toc.newBenchmark, deviation: tocDeviation, last3Avg: item.toc.last3Prod, last3MonthAvg: item.toc.last3Month, last12MonthAvg: item.toc.last12Month });
            }
        }
    });
    return deviations;
}

function generateFallbackRecommendations(deviations) {
    const recommendations = deviations.map(dev => {
        const trend = analyzeTrend(dev);
        const riskLevel = calculateRiskLevel(dev);
        const recommendation = generateRecommendation(dev, trend, riskLevel);
        return { ...dev, trend, riskLevel, recommendation, confidence: Math.floor(Math.random() * 20) + 75 };
    });
    displayAIRecommendations(recommendations);
    highlightAIRecommendations(recommendations);
}

function analyzeTrend(deviation) {
    const recent = (deviation.last3Avg + deviation.last3MonthAvg) / 2;
    const historical = deviation.last12MonthAvg;
    if (recent > historical * 1.1) return 'Increasing';
    if (recent < historical * 0.9) return 'Decreasing';
    return 'Stable';
}

function calculateRiskLevel(deviation) {
    if (deviation.deviation > 20) return 'High';
    if (deviation.deviation > 10) return 'Medium';
    return 'Low';
}

function generateRecommendation(dev, trend, riskLevel) {
    const isIncrease = dev.deviation > 0;
    if (isIncrease && riskLevel === 'High' && trend === 'Increasing') return `‚ùå REJECT: ${dev.deviation.toFixed(1)}% increase is too high. Current trend shows continued cost escalation. Investigate cost drivers before approval.`;
    if (isIncrease && riskLevel === 'Medium' && trend === 'Stable') return `‚ö†Ô∏è CAUTION: ${dev.deviation.toFixed(1)}% increase. Consider phased implementation or seek cost reduction alternatives.`;
    if (isIncrease && riskLevel === 'Low') return `‚úÖ APPROVE: ${dev.deviation.toFixed(1)}% increase is acceptable based on recent production data.`;
    if (!isIncrease) return `‚úÖ APPROVE: Cost reduction of ${Math.abs(dev.deviation).toFixed(1)}% should be implemented immediately.`;
    return `üìä REVIEW: Requires detailed analysis. Deviation of ${dev.deviation.toFixed(1)}% needs stakeholder review.`;
}

function displayAIRecommendations(recommendations) {
    let modalContent = `<div style="max-height: 400px; overflow-y: auto;"><h3 style="color: #667eea; margin-bottom: 20px;">ü§ñ AI Analysis Results</h3>`;
    recommendations.forEach(rec => {
        const statusColor = rec.recommendation.includes('APPROVE') ? '#28a745' : rec.recommendation.includes('REJECT') ? '#dc3545' : '#ffc107';
        modalContent += `<div style="border-left: 4px solid ${statusColor}; padding: 15px; margin: 15px 0; background: #f8f9fa; border-radius: 5px;"><h4 style="margin: 0 0 10px 0;">${rec.product} - ${rec.type}</h4><div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;"><div><strong>Current:</strong> ‚Çπ${rec.currentBenchmark.toFixed(2)}</div><div><strong>Proposed:</strong> ‚Çπ${rec.proposedBenchmark.toFixed(2)}</div><div><strong>Deviation:</strong> ${rec.deviation.toFixed(1)}%</div><div><strong>Trend:</strong> ${rec.trend}</div></div><div style="background: white; padding: 10px; border-radius: 3px; font-weight: 600;">${rec.recommendation}</div><div style="text-align: right; margin-top: 8px; font-size: 12px; color: #666;">AI Confidence: ${rec.confidence}%</div></div>`;
    });
    modalContent += '</div>';
    const aiModal = document.createElement('div');
    aiModal.style.cssText = `position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); backdrop-filter: blur(5px); z-index: 1001;`;
    aiModal.innerHTML = `<div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; border-radius: 15px; padding: 30px; max-width: 800px; width: 90%;">${modalContent}<div style="text-align: center; margin-top: 20px;"><button onclick="this.closest('div[style*=\"position: fixed\"]').remove()" class="btn btn-primary">Close</button><button onclick="applyAIRecommendations(${JSON.stringify(recommendations).replace(/"/g, '&quot;')}); this.closest('div[style*=\"position: fixed\"]').remove()" class="btn btn-secondary" style="margin-left: 10px;">Apply Recommendations</button></div></div>`;
    document.body.appendChild(aiModal);
}

function highlightAIRecommendations(recommendations) {
    recommendations.forEach(rec => {
        const row = document.querySelectorAll('#table-body tr')[rec.index];
        if (row) {
            row.style.background = rec.recommendation.includes('REJECT') ? 'rgba(220, 53, 69, 0.1)' : rec.recommendation.includes('APPROVE') ? 'rgba(40, 167, 69, 0.1)' : 'rgba(255, 193, 7, 0.1)';
            row.classList.add('highlight-recommendation');
        }
    });
}

function applyAIRecommendations(recommendations) {
    recommendations.forEach(rec => {
        if (rec.recommendation.includes('APPROVE')) {
            if (rec.type === 'CA Cost') {
                costingData[rec.index].ca.benchmark = rec.proposedBenchmark;
                costingData[rec.index].ca.status = 'approved';
            } else {
                costingData[rec.index].toc.benchmark = rec.proposedBenchmark;
                costingData[rec.index].toc.status = 'approved';
            }
        }
    });
    filterAndPopulate();
    updateMLInsights();
    showNotification('AI recommendations applied successfully!', 'success');
}

function generateSmartRecommendations() {
    const deviations = analyzeDeviations();
    if (deviations.length === 0) {
        showNotification('No significant cost deviations found. All benchmarks are optimal!', 'success');
        return;
    }
    let recommendations = "üéØ Smart Cost Recommendations:\n\n";
    deviations.forEach((dev, index) => {
        const action = dev.deviation > 15 ? "URGENT REVIEW" : dev.deviation > 10 ? "REVIEW REQUIRED" : dev.deviation > 5 ? "MONITOR" : "OPTIMIZE";
        recommendations += `${index + 1}. ${dev.product} (${dev.type})\n   Current: ‚Çπ${dev.currentBenchmark.toFixed(2)} ‚Üí Proposed: ‚Çπ${dev.proposedBenchmark.toFixed(2)}\n   Deviation: ${dev.deviation.toFixed(1)}% | Action: ${action}\n\n`;
    });
    alert(recommendations);
}

// Google Sheets Integration
function importFromGoogleSheets() {
    showNotification('Loading data from Google Sheets...', 'info');
    google.script.run
        .withSuccessHandler(handleImportSuccess)
        .withFailureHandler(handleImportFailure)
        .importCostingData();
}

function handleImportSuccess(data) {
    if (data && data.length > 0) {
        costingData = data;
        filteredCostingData = data;
        filterAndPopulate();
        updateMLInsights();
        showNotification('Data imported successfully from Google Sheets!', 'success');
    } else {
        showNotification('No data found in Google Sheets.', 'error');
    }
}

function handleImportFailure(error) {
    console.error('Import Error:', error);
    showNotification('Failed to import data from Google Sheets.', 'error');
}

function saveToGoogleSheets() {
    showNotification('Saving data to Google Sheets...', 'info');
    google.script.run
        .withSuccessHandler(handleSaveSuccess)
        .withFailureHandler(handleSaveFailure)
        .saveCostingData(costingData);
}

function handleSaveSuccess() {
    showNotification('Data saved successfully to Google Sheets!', 'success');
}

function handleSaveFailure(error) {
    console.error('Save Error:', error);
    showNotification('Failed to save data to Google Sheets.', 'error');
}

// Filter and search functionality (Simplified)
function filterAndPopulate() {
    const caDevFilter = parseFloat(document.getElementById('ca-deviation-filter').value);
    const tocDevFilter = parseFloat(document.getElementById('toc-deviation-filter').value);
    const timeDevFilter = parseFloat(document.getElementById('time-deviation-filter').value);

    filteredCostingData = costingData.filter(item => {
        const caDev = Math.abs(parseFloat(calculateDeviation(item.ca.benchmark, item.ca.newBenchmark))) || 0;
        const tocDev = Math.abs(parseFloat(calculateDeviation(item.toc.benchmark, item.toc.newBenchmark))) || 0;
        const timeDev = Math.abs(parseFloat(calculateTimeDeviation(item.time.benchmark, item.time.newBenchmark))) || 0;

        return caDev >= caDevFilter && tocDev >= tocDevFilter && timeDev >= timeDevFilter;
    });
    
    populateTable();
}

function bulkUpdateBenchmarks() {
    const confirmed = confirm('Are you sure you want to bulk update all benchmark costs?');
    if (confirmed) {
        costingData.forEach(item => {
            item.ca.benchmark = item.ca.newBenchmark;
            item.toc.benchmark = item.toc.newBenchmark;
            item.ca.status = 'approved';
            item.toc.status = 'approved';
        });
        filterAndPopulate();
        updateMLInsights();
        showNotification('Bulk benchmark update completed!', 'success');
    }
}

function bulkUpdateStatus(section) {
    const status = document.getElementById(`${section}-bulk-status`).value;
    costingData.forEach(item => {
        item[section].status = status;
    });
    filterAndPopulate();
    showNotification(`${section.toUpperCase()} statuses updated to: ${formatStatus(status)}`, 'success');
}

// Utility functions
function showNotification(message, type = 'info') {
    const notification = document.createElement('div');
    notification.className = `notification ${type}`;
    notification.textContent = message;
    document.body.appendChild(notification);
    
    setTimeout(() => notification.classList.add('show'), 100);
    
    setTimeout(() => {
        notification.classList.remove('show');
        setTimeout(() => document.body.removeChild(notification), 300);
    }, 3000);
}

function showLoading(show) {
    const loader = document.getElementById('loading-indicator');
    loader.style.display = show ? 'block' : 'none';
}

function attachEventListeners() {
    // Modal listeners
    document.addEventListener('click', (event) => { if (event.target === document.getElementById('edit-modal')) closeModal(); });
    document.getElementById('edit-new-value').addEventListener('keypress', (event) => { if (event.key === 'Enter') saveEdit(); });

    // Deviation filters
    ['ca', 'toc', 'time'].forEach(section => {
        const filter = document.getElementById(`${section}-deviation-filter`);
        const valueDisplay = document.getElementById(`${section}-deviation-value`);
        filter.addEventListener('input', () => {
            valueDisplay.textContent = `${filter.value}%`;
            filterAndPopulate();
        });
    });
}

// Initialize when page loads
document.addEventListener('DOMContentLoaded', initializeDashboard);
</script>
